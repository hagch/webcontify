package io.webcontify.backend.collections.services.field.handler

import io.webcontify.backend.collections.exceptions.UnprocessableContentException
import io.webcontify.backend.collections.models.dtos.*
import io.webcontify.backend.collections.models.errors.ErrorCode
import java.util.*
import org.jooq.ConstraintEnforcementStep
import org.jooq.DataType
import org.jooq.JSONB
import org.jooq.impl.DSL.constraint
import org.jooq.impl.DSL.field
import org.jooq.jackson.extensions.converters.JSONBtoJacksonConverter
import org.springframework.util.CollectionUtils

interface FieldHandler<T> {
  fun getFieldType(): DataType<T>?

  @Suppress("UNCHECKED_CAST")
  fun getFieldType(field: WebContifyCollectionFieldDto, isAutogenerated: Boolean): DataType<T>? {
    var type = getFieldType() ?: return null
    field.configuration?.let {
      if (field.isPrimaryKey) {
        type = type.nullable(false)
      } else {
        if (it.nullable != null) {
          type = type.nullable(it.nullable!!)
        }
        if (it.defaultValue != null && isAutogenerated) {
          type = type.defaultValue(it.defaultValue as T)
        }
      }
    }
    return type
  }

  @Throws(CastException::class) fun castToJavaType(value: Any?): T?

  fun getFieldConstraints(
      field: WebContifyCollectionFieldDto,
      tableName: String
  ): List<ConstraintEnforcementStep> {
    field.configuration?.let { configuration ->
      val constraints = mutableListOf<ConstraintEnforcementStep>()
      if (configuration.unique == true) {
        constraints.add(constraint("unique_${tableName}_${field.name}").unique(field(field.name)))
      }
      try {
        if (!configuration.inValues.isNullOrEmpty()) {
          constraints.add(
              constraint("in_values_${tableName}_${field.name}")
                  .check(field(field.name).`in`(configuration.inValues?.map { it })))
        }
      } catch (exception: CastException) {
        throw UnprocessableContentException(
            ErrorCode.INVALID_IN_VALUE_CONFIGURATION,
            configuration.inValues.toString(),
            field.name,
            field.type.name)
      }
      return constraints.toList()
    }
    return listOf()
  }

  fun mapConfigurationToJSONB(
      configuration: WebContifyCollectionFieldConfigurationDto<*>?
  ): JSONB? {
    return JSONBtoJacksonConverter(WebContifyCollectionFieldConfigurationDto::class.java)
        .to(configuration)
  }

  fun mapJSONBToConfiguration(configuration: JSONB?): WebContifyCollectionFieldConfigurationDto<T>?

  @Throws(ValidationException::class)
  fun validateField(value: T?, configuration: WebContifyCollectionFieldConfigurationDto<Any>?): T? {
    configuration?.let {
      if (it.nullable == false && Objects.isNull(value) && Objects.isNull(it.defaultValue)) {
        throw ValidationException()
      }
      val validatedValue =
          if (Objects.nonNull(it.defaultValue) && Objects.isNull(value)) {
            @Suppress("UNCHECKED_CAST")
            it.defaultValue as T
          } else {
            value
          }
      if (!CollectionUtils.isEmpty(it.inValues) && it.inValues?.contains(validatedValue) == false) {
        throw ValidationException()
      }
      return validatedValue
    }
    return value
  }

  fun castAndValidate(
      value: Any?,
      configuration: WebContifyCollectionFieldConfigurationDto<Any>?
  ): T? {
    val castedValue = castToJavaType(value)
    return validateField(castedValue, configuration)
  }
}
